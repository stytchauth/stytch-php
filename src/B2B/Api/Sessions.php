<?php

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

namespace Stytch\B2B\Api;

use Stytch\Core\Client;

class Sessions
{
    private Client $client;
    private string $projectId;
    private \Stytch\Shared\PolicyCache $policyCache;


    public function __construct(Client $client, string $projectId, \Stytch\Shared\PolicyCache $policyCache)
    {
        $this->client = $client;
        $this->projectId = $projectId;
        $this->policyCache = $policyCache;

    }

/**
    * Retrieves all active Sessions for a Member.

     * @param \Stytch\B2B\Models\Sessions\GetRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\GetResponse
     */
    public function get(
        \Stytch\B2B\Models\Sessions\GetRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\GetResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->get('/v1/b2b/sessions', $data);
        return \Stytch\B2B\Models\Sessions\GetResponse::fromArray($response);
    }

    /**
    * Retrieves all active Sessions for a Member.

     * @param \Stytch\B2B\Models\Sessions\GetRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsync(
        \Stytch\B2B\Models\Sessions\GetRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->getAsync('/v1/b2b/sessions', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\GetResponse::fromArray($response);
        });
    }

/**
    * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
    * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires
    * either a `session_jwt` or `session_token` be included in the request. It will return an error if both
    * are present.
    * 
    * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT
    * will be returned if both the signature and the underlying Session are still valid. See our
    * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
    * for more information.
    * 
    * If an `authorization_check` object is passed in, this method will also check if the Member is authorized
    * to perform the given action on the given Resource in the specified Organization. A Member is authorized
    * if their Member Session contains a Role, assigned
    * [explicitly or implicitly](https://stytch.com/docs/b2b/guides/rbac/role-assignment), with adequate
    * permissions.
    * In addition, the `organization_id` passed in the authorization check must match the Member's
    * Organization.
    * 
    * If the Member is not authorized to perform the specified action on the specified Resource, or if the
    * `organization_id` does not match the Member's Organization, a 403 error will be thrown.
    * Otherwise, the response will contain a list of Roles that satisfied the authorization check.

     * @param \Stytch\B2B\Models\Sessions\AuthenticateRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\AuthenticateResponse
     */
    public function authenticate(
        \Stytch\B2B\Models\Sessions\AuthenticateRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\AuthenticateResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/authenticate', $data);
        return \Stytch\B2B\Models\Sessions\AuthenticateResponse::fromArray($response);
    }

    /**
    * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
    * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires
    * either a `session_jwt` or `session_token` be included in the request. It will return an error if both
    * are present.
    * 
    * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT
    * will be returned if both the signature and the underlying Session are still valid. See our
    * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
    * for more information.
    * 
    * If an `authorization_check` object is passed in, this method will also check if the Member is authorized
    * to perform the given action on the given Resource in the specified Organization. A Member is authorized
    * if their Member Session contains a Role, assigned
    * [explicitly or implicitly](https://stytch.com/docs/b2b/guides/rbac/role-assignment), with adequate
    * permissions.
    * In addition, the `organization_id` passed in the authorization check must match the Member's
    * Organization.
    * 
    * If the Member is not authorized to perform the specified action on the specified Resource, or if the
    * `organization_id` does not match the Member's Organization, a 403 error will be thrown.
    * Otherwise, the response will contain a list of Roles that satisfied the authorization check.

     * @param \Stytch\B2B\Models\Sessions\AuthenticateRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authenticateAsync(
        \Stytch\B2B\Models\Sessions\AuthenticateRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/authenticate', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\AuthenticateResponse::fromArray($response);
        });
    }

/**
    * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either
    * the `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass
    * the `member_id`.

     * @param \Stytch\B2B\Models\Sessions\RevokeRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\RevokeResponse
     */
    public function revoke(
        \Stytch\B2B\Models\Sessions\RevokeRequest|array $request,
        \Stytch\B2B\Models\Sessions\RevokeRequestOptions|array $options = [],
    ): \Stytch\B2B\Models\Sessions\RevokeResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $opts = is_array($options) ? $options : $options->toArray();
        $response = $this->client->post('/v1/b2b/sessions/revoke', $data, $opts);
        return \Stytch\B2B\Models\Sessions\RevokeResponse::fromArray($response);
    }

    /**
    * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either
    * the `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass
    * the `member_id`.

     * @param \Stytch\B2B\Models\Sessions\RevokeRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeAsync(
        \Stytch\B2B\Models\Sessions\RevokeRequest|array $request,
        \Stytch\B2B\Models\Sessions\RevokeRequestOptions|array $options = [],
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $opts = is_array($options) ? $options : $options->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/revoke', $data, $opts);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\RevokeResponse::fromArray($response);
        });
    }

/**
    * Use this endpoint to exchange a Member's existing session for another session in a different
    * Organization. This can be used to accept an invite, but not to create a new member via domain matching.
    * 
    * To create a new member via email domain JIT Provisioning, use the
    * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow
    * instead.
    * 
    * If the user **has** already satisfied the authentication requirements of the Organization they are
    * trying to switch into, this API will return `member_authenticated: true` and a `session_token` and
    * `session_jwt`.
    * 
    * If the user **has not** satisfied the primary or secondary authentication requirements of the
    * Organization they are attempting to switch into, this API will return `member_authenticated: false` and
    * an `intermediate_session_token`.
    * 
    * If `primary_required` is set, prompt the user to fulfill the Organization's auth requirements using the
    * options returned in `primary_required.allowed_auth_methods`.
    * 
    * If `primary_required` is null and `mfa_required` is set, check `mfa_required.member_options` to
    * determine if the Member has SMS OTP or TOTP set up for MFA and prompt accordingly. If the Member has SMS
    * OTP, check `mfa_required.secondary_auth_initiated` to see if the OTP has already been sent.
    * 
    * Include the `intermediate_session_token` returned above when calling the `authenticate()` method that
    * the user needed to perform. Once the user has completed the authentication requirements they were
    * missing, they will be granted a full `session_token` and `session_jwt` to indicate they have
    * successfully logged into the Organization.
    * 
    * The `intermediate_session_token` can also be used with the
    * [Exchange Intermediate Session endpoint](https://stytch.com/docs/b2b/api/exchange-intermediate-session)
    * or the
    * [Create Organization via Discovery endpoint](https://stytch.com/docs/b2b/api/create-organization-via-discovery) to join a different Organization or create a new one.
    * The `session_duration_minutes` and `session_custom_claims` parameters will be ignored.

     * @param \Stytch\B2B\Models\Sessions\ExchangeRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\ExchangeResponse
     */
    public function exchange(
        \Stytch\B2B\Models\Sessions\ExchangeRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\ExchangeResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/exchange', $data);
        return \Stytch\B2B\Models\Sessions\ExchangeResponse::fromArray($response);
    }

    /**
    * Use this endpoint to exchange a Member's existing session for another session in a different
    * Organization. This can be used to accept an invite, but not to create a new member via domain matching.
    * 
    * To create a new member via email domain JIT Provisioning, use the
    * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow
    * instead.
    * 
    * If the user **has** already satisfied the authentication requirements of the Organization they are
    * trying to switch into, this API will return `member_authenticated: true` and a `session_token` and
    * `session_jwt`.
    * 
    * If the user **has not** satisfied the primary or secondary authentication requirements of the
    * Organization they are attempting to switch into, this API will return `member_authenticated: false` and
    * an `intermediate_session_token`.
    * 
    * If `primary_required` is set, prompt the user to fulfill the Organization's auth requirements using the
    * options returned in `primary_required.allowed_auth_methods`.
    * 
    * If `primary_required` is null and `mfa_required` is set, check `mfa_required.member_options` to
    * determine if the Member has SMS OTP or TOTP set up for MFA and prompt accordingly. If the Member has SMS
    * OTP, check `mfa_required.secondary_auth_initiated` to see if the OTP has already been sent.
    * 
    * Include the `intermediate_session_token` returned above when calling the `authenticate()` method that
    * the user needed to perform. Once the user has completed the authentication requirements they were
    * missing, they will be granted a full `session_token` and `session_jwt` to indicate they have
    * successfully logged into the Organization.
    * 
    * The `intermediate_session_token` can also be used with the
    * [Exchange Intermediate Session endpoint](https://stytch.com/docs/b2b/api/exchange-intermediate-session)
    * or the
    * [Create Organization via Discovery endpoint](https://stytch.com/docs/b2b/api/create-organization-via-discovery) to join a different Organization or create a new one.
    * The `session_duration_minutes` and `session_custom_claims` parameters will be ignored.

     * @param \Stytch\B2B\Models\Sessions\ExchangeRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exchangeAsync(
        \Stytch\B2B\Models\Sessions\ExchangeRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/exchange', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\ExchangeResponse::fromArray($response);
        });
    }

/**
    * Use this endpoint to exchange a Connected Apps Access Token back into a Member Session for the
    * underlying Member. 
    * This session can be used with the Stytch SDKs and APIs.
    * 
    * The Access Token must contain the `full_access` scope (only available to First Party clients) and must
    * not be more than 5 minutes old. Access Tokens may only be exchanged a single time. 
    * 
    * The Member Session returned will be the same Member Session that was active in your application (the
    * authorizing party) during the initial authorization flow.
    * 
    * Because the Member previously completed MFA and satisfied all Organization authentication requirements
    * at the time of the original Access Token issuance, this endpoint will never return an
    * `intermediate_session_token` or require MFA.

     * @param \Stytch\B2B\Models\Sessions\ExchangeAccessTokenRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\ExchangeAccessTokenResponse
     */
    public function exchangeAccessToken(
        \Stytch\B2B\Models\Sessions\ExchangeAccessTokenRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\ExchangeAccessTokenResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/exchange_access_token', $data);
        return \Stytch\B2B\Models\Sessions\ExchangeAccessTokenResponse::fromArray($response);
    }

    /**
    * Use this endpoint to exchange a Connected Apps Access Token back into a Member Session for the
    * underlying Member. 
    * This session can be used with the Stytch SDKs and APIs.
    * 
    * The Access Token must contain the `full_access` scope (only available to First Party clients) and must
    * not be more than 5 minutes old. Access Tokens may only be exchanged a single time. 
    * 
    * The Member Session returned will be the same Member Session that was active in your application (the
    * authorizing party) during the initial authorization flow.
    * 
    * Because the Member previously completed MFA and satisfied all Organization authentication requirements
    * at the time of the original Access Token issuance, this endpoint will never return an
    * `intermediate_session_token` or require MFA.

     * @param \Stytch\B2B\Models\Sessions\ExchangeAccessTokenRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exchangeAccessTokenAsync(
        \Stytch\B2B\Models\Sessions\ExchangeAccessTokenRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/exchange_access_token', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\ExchangeAccessTokenResponse::fromArray($response);
        });
    }

/**
    * Exchange an auth token issued by a trusted identity provider for a Stytch session. You must first
    * register a Trusted Auth Token profile in the Stytch dashboard
    * [here](https://stytch.com/dashboard/trusted-auth-tokens).  If a session token or session JWT is
    * provided, it will add the trusted auth token as an authentication factor to the existing session.

     * @param \Stytch\B2B\Models\Sessions\AttestRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\AttestResponse
     */
    public function attest(
        \Stytch\B2B\Models\Sessions\AttestRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\AttestResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/attest', $data);
        return \Stytch\B2B\Models\Sessions\AttestResponse::fromArray($response);
    }

    /**
    * Exchange an auth token issued by a trusted identity provider for a Stytch session. You must first
    * register a Trusted Auth Token profile in the Stytch dashboard
    * [here](https://stytch.com/dashboard/trusted-auth-tokens).  If a session token or session JWT is
    * provided, it will add the trusted auth token as an authentication factor to the existing session.

     * @param \Stytch\B2B\Models\Sessions\AttestRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attestAsync(
        \Stytch\B2B\Models\Sessions\AttestRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/attest', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\AttestResponse::fromArray($response);
        });
    }

/**
    * Migrate a session from an external OIDC compliant endpoint.
    * Stytch will call the external UserInfo endpoint defined in your Stytch Project settings in the
    * [Dashboard](https://stytch.com/dashboard/migrations), and then perform a lookup using the
    * `session_token`.
    * If the response contains a valid email address, Stytch will attempt to match that email address with an
    * existing Member in your Organization and create a Stytch Session.
    * You will need to create the member before using this endpoint.

     * @param \Stytch\B2B\Models\Sessions\MigrateRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\MigrateResponse
     */
    public function migrate(
        \Stytch\B2B\Models\Sessions\MigrateRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\MigrateResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/migrate', $data);
        return \Stytch\B2B\Models\Sessions\MigrateResponse::fromArray($response);
    }

    /**
    * Migrate a session from an external OIDC compliant endpoint.
    * Stytch will call the external UserInfo endpoint defined in your Stytch Project settings in the
    * [Dashboard](https://stytch.com/dashboard/migrations), and then perform a lookup using the
    * `session_token`.
    * If the response contains a valid email address, Stytch will attempt to match that email address with an
    * existing Member in your Organization and create a Stytch Session.
    * You will need to create the member before using this endpoint.

     * @param \Stytch\B2B\Models\Sessions\MigrateRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function migrateAsync(
        \Stytch\B2B\Models\Sessions\MigrateRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/migrate', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\MigrateResponse::fromArray($response);
        });
    }

/**
    * Get the JSON Web Key Set (JWKS) for a project.
    * 
    * Within the JWKS, the JSON Web Keys are rotated every ~6 months. Upon rotation, new JWTs will be signed
    * using the new key, and both keys will be returned by this endpoint for a period of 1 month.
    * 
    * JWTs have a set lifetime of 5 minutes, so there will be a 5 minute period where some JWTs will be signed
    * by the old keys, and some JWTs will be signed by the new keys. The correct key to use for validation is
    * determined by matching the `kid` value of the JWT and key.
    * 
    * If you're using one of our [backend SDKs](https://stytch.com/docs/b2b/sdks), the JSON Web Key (JWK)
    * rotation will be handled for you.
    * 
    * If you're using your own JWT validation library, many have built-in support for JWK rotation, and you'll
    * just need to supply this API endpoint. If not, your application should decide which JWK to use for
    * validation by inspecting the `kid` value.
    * 
    * See our
    * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
    * for more information.

     * @param \Stytch\B2B\Models\Sessions\GetJWKSRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\GetJWKSResponse
     */
    public function getJWKS(
        \Stytch\B2B\Models\Sessions\GetJWKSRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\GetJWKSResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->get('/v1/b2b/sessions/jwks/{project_id}', $data);
        return \Stytch\B2B\Models\Sessions\GetJWKSResponse::fromArray($response);
    }

    /**
    * Get the JSON Web Key Set (JWKS) for a project.
    * 
    * Within the JWKS, the JSON Web Keys are rotated every ~6 months. Upon rotation, new JWTs will be signed
    * using the new key, and both keys will be returned by this endpoint for a period of 1 month.
    * 
    * JWTs have a set lifetime of 5 minutes, so there will be a 5 minute period where some JWTs will be signed
    * by the old keys, and some JWTs will be signed by the new keys. The correct key to use for validation is
    * determined by matching the `kid` value of the JWT and key.
    * 
    * If you're using one of our [backend SDKs](https://stytch.com/docs/b2b/sdks), the JSON Web Key (JWK)
    * rotation will be handled for you.
    * 
    * If you're using your own JWT validation library, many have built-in support for JWK rotation, and you'll
    * just need to supply this API endpoint. If not, your application should decide which JWK to use for
    * validation by inspecting the `kid` value.
    * 
    * See our
    * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
    * for more information.

     * @param \Stytch\B2B\Models\Sessions\GetJWKSRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJWKSAsync(
        \Stytch\B2B\Models\Sessions\GetJWKSRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->getAsync('/v1/b2b/sessions/jwks/{project_id}', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\GetJWKSResponse::fromArray($response);
        });
    }

}
