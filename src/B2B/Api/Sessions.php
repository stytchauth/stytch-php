<?php

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

namespace Stytch\B2B\Api;

use Stytch\Core\Client;

class Sessions
{
    private Client $client;
    private string $projectId;
    private \Stytch\Shared\JwksCache $jwksCache;
    private \Stytch\Shared\PolicyCache $policyCache;


    public function __construct(Client $client, string $projectId, \Stytch\Shared\JwksCache $jwksCache, \Stytch\Shared\PolicyCache $policyCache)
    {
        $this->client = $client;
        $this->projectId = $projectId;
        $this->jwksCache = $jwksCache;
        $this->policyCache = $policyCache;

    }

    /**
        * Retrieves all active Sessions for a Member.

         * @param \Stytch\B2B\Models\Sessions\GetRequest|array $request
         * @return \Stytch\B2B\Models\Sessions\GetResponse
         */
    public function get(
        \Stytch\B2B\Models\Sessions\GetRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\GetResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->get('/v1/b2b/sessions', $data);
        return \Stytch\B2B\Models\Sessions\GetResponse::fromArray($response);
    }

    /**
    * Retrieves all active Sessions for a Member.

     * @param \Stytch\B2B\Models\Sessions\GetRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsync(
        \Stytch\B2B\Models\Sessions\GetRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->getAsync('/v1/b2b/sessions', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\GetResponse::fromArray($response);
        });
    }

    /**
        * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
        * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires
        * either a `session_jwt` or `session_token` be included in the request. It will return an error if both
        * are present.
        *
        * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT
        * will be returned if both the signature and the underlying Session are still valid. See our
        * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
        * for more information.
        *
        * If an `authorization_check` object is passed in, this method will also check if the Member is authorized
        * to perform the given action on the given Resource in the specified Organization. A Member is authorized
        * if their Member Session contains a Role, assigned
        * [explicitly or implicitly](https://stytch.com/docs/b2b/guides/rbac/role-assignment), with adequate
        * permissions.
        * In addition, the `organization_id` passed in the authorization check must match the Member's
        * Organization.
        *
        * If the Member is not authorized to perform the specified action on the specified Resource, or if the
        * `organization_id` does not match the Member's Organization, a 403 error will be thrown.
        * Otherwise, the response will contain a list of Roles that satisfied the authorization check.

         * @param \Stytch\B2B\Models\Sessions\AuthenticateRequest|array $request
         * @return \Stytch\B2B\Models\Sessions\AuthenticateResponse
         */
    public function authenticate(
        \Stytch\B2B\Models\Sessions\AuthenticateRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\AuthenticateResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/authenticate', $data);
        return \Stytch\B2B\Models\Sessions\AuthenticateResponse::fromArray($response);
    }

    /**
    * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
    * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires
    * either a `session_jwt` or `session_token` be included in the request. It will return an error if both
    * are present.
    *
    * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT
    * will be returned if both the signature and the underlying Session are still valid. See our
    * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
    * for more information.
    *
    * If an `authorization_check` object is passed in, this method will also check if the Member is authorized
    * to perform the given action on the given Resource in the specified Organization. A Member is authorized
    * if their Member Session contains a Role, assigned
    * [explicitly or implicitly](https://stytch.com/docs/b2b/guides/rbac/role-assignment), with adequate
    * permissions.
    * In addition, the `organization_id` passed in the authorization check must match the Member's
    * Organization.
    *
    * If the Member is not authorized to perform the specified action on the specified Resource, or if the
    * `organization_id` does not match the Member's Organization, a 403 error will be thrown.
    * Otherwise, the response will contain a list of Roles that satisfied the authorization check.

     * @param \Stytch\B2B\Models\Sessions\AuthenticateRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authenticateAsync(
        \Stytch\B2B\Models\Sessions\AuthenticateRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/authenticate', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\AuthenticateResponse::fromArray($response);
        });
    }

    /**
        * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either
        * the `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass
        * the `member_id`.

         * @param \Stytch\B2B\Models\Sessions\RevokeRequest|array $request
         * @return \Stytch\B2B\Models\Sessions\RevokeResponse
         */
    public function revoke(
        \Stytch\B2B\Models\Sessions\RevokeRequest|array $request,
        \Stytch\B2B\Models\Sessions\RevokeRequestOptions|array $options = [],
    ): \Stytch\B2B\Models\Sessions\RevokeResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $opts = is_array($options) ? $options : $options->toArray();
        $response = $this->client->post('/v1/b2b/sessions/revoke', $data, $opts);
        return \Stytch\B2B\Models\Sessions\RevokeResponse::fromArray($response);
    }

    /**
    * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either
    * the `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass
    * the `member_id`.

     * @param \Stytch\B2B\Models\Sessions\RevokeRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeAsync(
        \Stytch\B2B\Models\Sessions\RevokeRequest|array $request,
        \Stytch\B2B\Models\Sessions\RevokeRequestOptions|array $options = [],
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $opts = is_array($options) ? $options : $options->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/revoke', $data, $opts);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\RevokeResponse::fromArray($response);
        });
    }

    /**
        * Use this endpoint to exchange a Member's existing session for another session in a different
        * Organization. This can be used to accept an invite, but not to create a new member via domain matching.
        *
        * To create a new member via email domain JIT Provisioning, use the
        * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow
        * instead.
        *
        * If the user **has** already satisfied the authentication requirements of the Organization they are
        * trying to switch into, this API will return `member_authenticated: true` and a `session_token` and
        * `session_jwt`.
        *
        * If the user **has not** satisfied the primary or secondary authentication requirements of the
        * Organization they are attempting to switch into, this API will return `member_authenticated: false` and
        * an `intermediate_session_token`.
        *
        * If `primary_required` is set, prompt the user to fulfill the Organization's auth requirements using the
        * options returned in `primary_required.allowed_auth_methods`.
        *
        * If `primary_required` is null and `mfa_required` is set, check `mfa_required.member_options` to
        * determine if the Member has SMS OTP or TOTP set up for MFA and prompt accordingly. If the Member has SMS
        * OTP, check `mfa_required.secondary_auth_initiated` to see if the OTP has already been sent.
        *
        * Include the `intermediate_session_token` returned above when calling the `authenticate()` method that
        * the user needed to perform. Once the user has completed the authentication requirements they were
        * missing, they will be granted a full `session_token` and `session_jwt` to indicate they have
        * successfully logged into the Organization.
        *
        * The `intermediate_session_token` can also be used with the
        * [Exchange Intermediate Session endpoint](https://stytch.com/docs/b2b/api/exchange-intermediate-session)
        * or the
        * [Create Organization via Discovery endpoint](https://stytch.com/docs/b2b/api/create-organization-via-discovery) to join a different Organization or create a new one.
        * The `session_duration_minutes` and `session_custom_claims` parameters will be ignored.

         * @param \Stytch\B2B\Models\Sessions\ExchangeRequest|array $request
         * @return \Stytch\B2B\Models\Sessions\ExchangeResponse
         */
    public function exchange(
        \Stytch\B2B\Models\Sessions\ExchangeRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\ExchangeResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/exchange', $data);
        return \Stytch\B2B\Models\Sessions\ExchangeResponse::fromArray($response);
    }

    /**
    * Use this endpoint to exchange a Member's existing session for another session in a different
    * Organization. This can be used to accept an invite, but not to create a new member via domain matching.
    *
    * To create a new member via email domain JIT Provisioning, use the
    * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow
    * instead.
    *
    * If the user **has** already satisfied the authentication requirements of the Organization they are
    * trying to switch into, this API will return `member_authenticated: true` and a `session_token` and
    * `session_jwt`.
    *
    * If the user **has not** satisfied the primary or secondary authentication requirements of the
    * Organization they are attempting to switch into, this API will return `member_authenticated: false` and
    * an `intermediate_session_token`.
    *
    * If `primary_required` is set, prompt the user to fulfill the Organization's auth requirements using the
    * options returned in `primary_required.allowed_auth_methods`.
    *
    * If `primary_required` is null and `mfa_required` is set, check `mfa_required.member_options` to
    * determine if the Member has SMS OTP or TOTP set up for MFA and prompt accordingly. If the Member has SMS
    * OTP, check `mfa_required.secondary_auth_initiated` to see if the OTP has already been sent.
    *
    * Include the `intermediate_session_token` returned above when calling the `authenticate()` method that
    * the user needed to perform. Once the user has completed the authentication requirements they were
    * missing, they will be granted a full `session_token` and `session_jwt` to indicate they have
    * successfully logged into the Organization.
    *
    * The `intermediate_session_token` can also be used with the
    * [Exchange Intermediate Session endpoint](https://stytch.com/docs/b2b/api/exchange-intermediate-session)
    * or the
    * [Create Organization via Discovery endpoint](https://stytch.com/docs/b2b/api/create-organization-via-discovery) to join a different Organization or create a new one.
    * The `session_duration_minutes` and `session_custom_claims` parameters will be ignored.

     * @param \Stytch\B2B\Models\Sessions\ExchangeRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exchangeAsync(
        \Stytch\B2B\Models\Sessions\ExchangeRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/exchange', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\ExchangeResponse::fromArray($response);
        });
    }

    /**
        * Use this endpoint to exchange a Connected Apps Access Token back into a Member Session for the
        * underlying Member.
        * This session can be used with the Stytch SDKs and APIs.
        *
        * The Access Token must contain the `full_access` scope (only available to First Party clients) and must
        * not be more than 5 minutes old. Access Tokens may only be exchanged a single time.
        *
        * The Member Session returned will be the same Member Session that was active in your application (the
        * authorizing party) during the initial authorization flow.
        *
        * Because the Member previously completed MFA and satisfied all Organization authentication requirements
        * at the time of the original Access Token issuance, this endpoint will never return an
        * `intermediate_session_token` or require MFA.

         * @param \Stytch\B2B\Models\Sessions\ExchangeAccessTokenRequest|array $request
         * @return \Stytch\B2B\Models\Sessions\ExchangeAccessTokenResponse
         */
    public function exchangeAccessToken(
        \Stytch\B2B\Models\Sessions\ExchangeAccessTokenRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\ExchangeAccessTokenResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/exchange_access_token', $data);
        return \Stytch\B2B\Models\Sessions\ExchangeAccessTokenResponse::fromArray($response);
    }

    /**
    * Use this endpoint to exchange a Connected Apps Access Token back into a Member Session for the
    * underlying Member.
    * This session can be used with the Stytch SDKs and APIs.
    *
    * The Access Token must contain the `full_access` scope (only available to First Party clients) and must
    * not be more than 5 minutes old. Access Tokens may only be exchanged a single time.
    *
    * The Member Session returned will be the same Member Session that was active in your application (the
    * authorizing party) during the initial authorization flow.
    *
    * Because the Member previously completed MFA and satisfied all Organization authentication requirements
    * at the time of the original Access Token issuance, this endpoint will never return an
    * `intermediate_session_token` or require MFA.

     * @param \Stytch\B2B\Models\Sessions\ExchangeAccessTokenRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exchangeAccessTokenAsync(
        \Stytch\B2B\Models\Sessions\ExchangeAccessTokenRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/exchange_access_token', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\ExchangeAccessTokenResponse::fromArray($response);
        });
    }

    /**
        * Exchange an auth token issued by a trusted identity provider for a Stytch session. You must first
        * register a Trusted Auth Token profile in the Stytch dashboard
        * [here](https://stytch.com/dashboard/trusted-auth-tokens).  If a session token or session JWT is
        * provided, it will add the trusted auth token as an authentication factor to the existing session.

         * @param \Stytch\B2B\Models\Sessions\AttestRequest|array $request
         * @return \Stytch\B2B\Models\Sessions\AttestResponse
         */
    public function attest(
        \Stytch\B2B\Models\Sessions\AttestRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\AttestResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/attest', $data);
        return \Stytch\B2B\Models\Sessions\AttestResponse::fromArray($response);
    }

    /**
    * Exchange an auth token issued by a trusted identity provider for a Stytch session. You must first
    * register a Trusted Auth Token profile in the Stytch dashboard
    * [here](https://stytch.com/dashboard/trusted-auth-tokens).  If a session token or session JWT is
    * provided, it will add the trusted auth token as an authentication factor to the existing session.

     * @param \Stytch\B2B\Models\Sessions\AttestRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attestAsync(
        \Stytch\B2B\Models\Sessions\AttestRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/attest', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\AttestResponse::fromArray($response);
        });
    }

    /**
        * Migrate a session from an external OIDC compliant endpoint.
        * Stytch will call the external UserInfo endpoint defined in your Stytch Project settings in the
        * [Dashboard](https://stytch.com/dashboard/migrations), and then perform a lookup using the
        * `session_token`.
        * If the response contains a valid email address, Stytch will attempt to match that email address with an
        * existing Member in your Organization and create a Stytch Session.
        * You will need to create the member before using this endpoint.

         * @param \Stytch\B2B\Models\Sessions\MigrateRequest|array $request
         * @return \Stytch\B2B\Models\Sessions\MigrateResponse
         */
    public function migrate(
        \Stytch\B2B\Models\Sessions\MigrateRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\MigrateResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/b2b/sessions/migrate', $data);
        return \Stytch\B2B\Models\Sessions\MigrateResponse::fromArray($response);
    }

    /**
    * Migrate a session from an external OIDC compliant endpoint.
    * Stytch will call the external UserInfo endpoint defined in your Stytch Project settings in the
    * [Dashboard](https://stytch.com/dashboard/migrations), and then perform a lookup using the
    * `session_token`.
    * If the response contains a valid email address, Stytch will attempt to match that email address with an
    * existing Member in your Organization and create a Stytch Session.
    * You will need to create the member before using this endpoint.

     * @param \Stytch\B2B\Models\Sessions\MigrateRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function migrateAsync(
        \Stytch\B2B\Models\Sessions\MigrateRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/b2b/sessions/migrate', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\MigrateResponse::fromArray($response);
        });
    }

    /**
        * Get the JSON Web Key Set (JWKS) for a project.
        *
        * Within the JWKS, the JSON Web Keys are rotated every ~6 months. Upon rotation, new JWTs will be signed
        * using the new key, and both keys will be returned by this endpoint for a period of 1 month.
        *
        * JWTs have a set lifetime of 5 minutes, so there will be a 5 minute period where some JWTs will be signed
        * by the old keys, and some JWTs will be signed by the new keys. The correct key to use for validation is
        * determined by matching the `kid` value of the JWT and key.
        *
        * If you're using one of our [backend SDKs](https://stytch.com/docs/b2b/sdks), the JSON Web Key (JWK)
        * rotation will be handled for you.
        *
        * If you're using your own JWT validation library, many have built-in support for JWK rotation, and you'll
        * just need to supply this API endpoint. If not, your application should decide which JWK to use for
        * validation by inspecting the `kid` value.
        *
        * See our
        * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
        * for more information.

         * @param \Stytch\B2B\Models\Sessions\GetJWKSRequest|array $request
         * @return \Stytch\B2B\Models\Sessions\GetJWKSResponse
         */
    public function getJWKS(
        \Stytch\B2B\Models\Sessions\GetJWKSRequest|array $request,
    ): \Stytch\B2B\Models\Sessions\GetJWKSResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->get('/v1/b2b/sessions/jwks/{project_id}', $data);
        return \Stytch\B2B\Models\Sessions\GetJWKSResponse::fromArray($response);
    }

    /**
    * Get the JSON Web Key Set (JWKS) for a project.
    *
    * Within the JWKS, the JSON Web Keys are rotated every ~6 months. Upon rotation, new JWTs will be signed
    * using the new key, and both keys will be returned by this endpoint for a period of 1 month.
    *
    * JWTs have a set lifetime of 5 minutes, so there will be a 5 minute period where some JWTs will be signed
    * by the old keys, and some JWTs will be signed by the new keys. The correct key to use for validation is
    * determined by matching the `kid` value of the JWT and key.
    *
    * If you're using one of our [backend SDKs](https://stytch.com/docs/b2b/sdks), the JSON Web Key (JWK)
    * rotation will be handled for you.
    *
    * If you're using your own JWT validation library, many have built-in support for JWK rotation, and you'll
    * just need to supply this API endpoint. If not, your application should decide which JWK to use for
    * validation by inspecting the `kid` value.
    *
    * See our
    * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
    * for more information.

     * @param \Stytch\B2B\Models\Sessions\GetJWKSRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJWKSAsync(
        \Stytch\B2B\Models\Sessions\GetJWKSRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->getAsync('/v1/b2b/sessions/jwks/{project_id}', $data);
        return $promise->then(function ($response) {
            return \Stytch\B2B\Models\Sessions\GetJWKSResponse::fromArray($response);
        });
    }

    // MANUAL(authenticateJwt)(SERVICE_METHOD)
    // ADDIMPORT: use Stytch\Shared\JwksCache;
    // ADDIMPORT: use Stytch\Shared\JwtHelpers;
    // ADDIMPORT: use Stytch\Shared\RbacLocal;

    /**
     * Parse a JWT and verify the signature, preferring local verification over remote.
     *
     * Tries local JWT validation first for performance. If local validation fails for any
     * reason (invalid signature, expired, etc.), falls back to network authentication.
     *
     * If max_token_age_seconds is set, remote verification will be forced if the JWT was issued
     * (based on the "iat" claim) more than that many seconds ago.
     *
     * To force remote validation for all tokens, set max_token_age_seconds to zero or use the
     * authenticate method instead.
     *
     * @param \Stytch\B2B\Models\Sessions\AuthenticateJwtRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\AuthenticateResponse
     */
    public function authenticateJwt(
        \Stytch\B2B\Models\Sessions\AuthenticateJwtRequest|array $request
    ): \Stytch\B2B\Models\Sessions\AuthenticateResponse {
        $data = is_array($request) ? $request : $request->toArray();

        try {
            $memberSession = $this->authenticateJwtLocal($request);

            // Return same response format as authenticate()
            // Build a response that matches AuthenticateResponse structure
            $responseData = [
                'status_code' => 200,
                'request_id' => '',
                'member_session' => $memberSession,
                'session_token' => '',
                'session_jwt' => $data['session_jwt'],
                'member' => null,
                'organization' => null,
            ];

            return \Stytch\B2B\Models\Sessions\AuthenticateResponse::fromArray($responseData);
        } catch (\Exception $e) {
            // JWT could not be verified locally. Fall back to Stytch API.
            return $this->authenticate([
                'session_jwt' => $data['session_jwt'],
                'authorization_check' => $data['authorization_check'] ?? null,
            ]);
        }
    }

    /**
     * Parse a JWT and verify the signature locally (without calling /authenticate in the API).
     *
     * If max_token_age_seconds is set, this will return an error if the JWT was issued (based on the "iat"
     * claim) more than max_token_age_seconds seconds ago.
     *
     * If max_token_age_seconds is explicitly set to zero, all tokens will be considered too old,
     * even if they are otherwise valid.
     *
     * The value for current_date is used to compare timestamp claims ("exp", "nbf", "iat"). It
     * defaults to the current date (new DateTime()).
     *
     * The value for clock_tolerance_seconds is the maximum allowable difference when comparing
     * timestamps. It defaults to zero.
     *
     * @param \Stytch\B2B\Models\Sessions\AuthenticateJwtLocalRequest|array $request
     * @return \Stytch\B2B\Models\Sessions\MemberSession
     * @throws \Stytch\Core\StytchException
     */
    public function authenticateJwtLocal(
        \Stytch\B2B\Models\Sessions\AuthenticateJwtLocalRequest|array $request
    ): \Stytch\B2B\Models\Sessions\MemberSession {
        $data = is_array($request) ? $request : $request->toArray();

        // Fetch JWKS (cached)
        $jwks = $this->jwksCache->fetch($this->projectId);

        // Validate JWT locally
        $result = \Stytch\Shared\JwtHelpers::authenticateJwtLocal(
            $jwks,
            $data['session_jwt'],
            $this->projectId,
            [
                'clock_tolerance_seconds' => $data['clock_tolerance_seconds'] ?? null,
                'max_token_age_seconds' => $data['max_token_age_seconds'] ?? null,
                'current_date' => $data['current_date'] ?? null,
            ]
        );

        $payload = $result['payload'];
        $customClaims = $result['custom_claims'];

        // Extract Stytch session claim
        $sessionClaim = $payload['https://stytch.com/session'] ?? null;
        if (!$sessionClaim) {
            throw new \Stytch\Core\StytchException('JWT missing session claim', 0);
        }

        // Convert to array if it's an object
        if (is_object($sessionClaim)) {
            $sessionClaim = (array) $sessionClaim;
        }

        // Extract B2B organization claim
        $orgClaim = $payload['https://stytch.com/organization'] ?? null;
        if (!$orgClaim) {
            throw new \Stytch\Core\StytchException('JWT missing organization claim', 0);
        }

        // Convert to array if it's an object
        if (is_object($orgClaim)) {
            $orgClaim = (array) $orgClaim;
        }

        $organizationId = $orgClaim['organization_id'] ?? '';
        $organizationSlug = $orgClaim['organization_slug'] ?? '';
        $memberId = $payload['sub'] ?? '';

        // RBAC authorization check
        if (isset($data['authorization_check']) && $data['authorization_check'] !== null) {
            $authCheck = is_array($data['authorization_check'])
                ? $data['authorization_check']
                : $data['authorization_check']->toArray();

            $roles = $sessionClaim['roles'] ?? [];

            // Check if the organization ID matches (if provided in authorization check)
            if (isset($authCheck['organization_id']) && $authCheck['organization_id'] !== $organizationId) {
                throw new \Stytch\Core\StytchException(
                    'Organization ID does not match',
                    0
                );
            }

            // Fetch policy from cache
            $cacheKey = \Stytch\Shared\PolicyCache::generateKey($organizationId, $memberId);
            $policy = $this->policyCache->get($cacheKey);

            if ($policy === null) {
                // Policy not in cache - fall back to network authentication
                // which will perform the authorization check via API
                throw new \Stytch\Core\StytchException(
                    'Policy not found in cache. Falling back to network authentication.',
                    0
                );
            }

            // Perform role-based authorization check
            \Stytch\Shared\RbacLocal::performRoleAuthorizationCheck(
                $policy,
                $roles,
                $authCheck,
                'Member'
            );
        }

        // Map to MemberSession object
        return \Stytch\B2B\Models\Sessions\MemberSession::fromArray([
            'member_session_id' => $sessionClaim['id'] ?? '',
            'member_id' => $memberId,
            'organization_id' => $organizationId,
            'started_at' => $sessionClaim['started_at'] ?? '',
            'last_accessed_at' => $sessionClaim['last_accessed_at'] ?? '',
            'expires_at' => $sessionClaim['expires_at'] ?? '',
            'attributes' => $sessionClaim['attributes'] ?? [],
            'authentication_factors' => $sessionClaim['authentication_factors'] ?? [],
            'custom_claims' => $customClaims,
        ]);
    }

    /**
     * Async version of authenticateJwt
     *
     * @param \Stytch\B2B\Models\Sessions\AuthenticateJwtRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authenticateJwtAsync(
        \Stytch\B2B\Models\Sessions\AuthenticateJwtRequest|array $request
    ): \GuzzleHttp\Promise\PromiseInterface {
        return \GuzzleHttp\Promise\Create::promiseFor($this->authenticateJwt($request));
    }

    /**
     * Async version of authenticateJwtLocal
     *
     * @param \Stytch\B2B\Models\Sessions\AuthenticateJwtLocalRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authenticateJwtLocalAsync(
        \Stytch\B2B\Models\Sessions\AuthenticateJwtLocalRequest|array $request
    ): \GuzzleHttp\Promise\PromiseInterface {
        return \GuzzleHttp\Promise\Create::promiseFor($this->authenticateJwtLocal($request));
    }
    // ENDMANUAL(authenticateJwt)


}
