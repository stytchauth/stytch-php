<?php

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

namespace Stytch\Consumer\Api;

use Stytch\Core\Client;

class Sessions
{
    private Client $client;
    private string $projectId;
    private \Stytch\Shared\JwksCache $jwksCache;
    private \Stytch\Shared\PolicyCache $policyCache;


    public function __construct(Client $client, string $projectId, \Stytch\Shared\JwksCache $jwksCache, \Stytch\Shared\PolicyCache $policyCache)
    {
        $this->client = $client;
        $this->projectId = $projectId;
        $this->jwksCache = $jwksCache;
        $this->policyCache = $policyCache;

    }

    /**
        * List all active Sessions for a given `user_id`. All timestamps are formatted according to the RFC 3339
        * standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.

         * @param \Stytch\Consumer\Models\Sessions\GetRequest|array $request
         * @return \Stytch\Consumer\Models\Sessions\GetResponse
         */
    public function get(
        \Stytch\Consumer\Models\Sessions\GetRequest|array $request,
    ): \Stytch\Consumer\Models\Sessions\GetResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->get('/v1/sessions', $data);
        return \Stytch\Consumer\Models\Sessions\GetResponse::fromArray($response);
    }

    /**
    * List all active Sessions for a given `user_id`. All timestamps are formatted according to the RFC 3339
    * standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.

     * @param \Stytch\Consumer\Models\Sessions\GetRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsync(
        \Stytch\Consumer\Models\Sessions\GetRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->getAsync('/v1/sessions', $data);
        return $promise->then(function ($response) {
            return \Stytch\Consumer\Models\Sessions\GetResponse::fromArray($response);
        });
    }

    /**
        * Authenticate a session token or session JWT and retrieve associated session data. If
        * `session_duration_minutes` is included, update the lifetime of the session to be that many minutes from
        * now. All timestamps are formatted according to the RFC 3339 standard and are expressed in UTC, e.g.
        * `2021-12-29T12:33:09Z`. This endpoint requires exactly one `session_jwt` or `session_token` as part of
        * the request. If both are included, you will receive a `too_many_session_arguments` error.
        *
        * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT
        * will be returned if both the signature and the underlying Session are still valid. See our
        * [How to use Stytch Session JWTs](https://stytch.com/docs/guides/sessions/using-jwts) guide for more
        * information.

         * @param \Stytch\Consumer\Models\Sessions\AuthenticateRequest|array $request
         * @return \Stytch\Consumer\Models\Sessions\AuthenticateResponse
         */
    public function authenticate(
        \Stytch\Consumer\Models\Sessions\AuthenticateRequest|array $request,
    ): \Stytch\Consumer\Models\Sessions\AuthenticateResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/sessions/authenticate', $data);
        return \Stytch\Consumer\Models\Sessions\AuthenticateResponse::fromArray($response);
    }

    /**
    * Authenticate a session token or session JWT and retrieve associated session data. If
    * `session_duration_minutes` is included, update the lifetime of the session to be that many minutes from
    * now. All timestamps are formatted according to the RFC 3339 standard and are expressed in UTC, e.g.
    * `2021-12-29T12:33:09Z`. This endpoint requires exactly one `session_jwt` or `session_token` as part of
    * the request. If both are included, you will receive a `too_many_session_arguments` error.
    *
    * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT
    * will be returned if both the signature and the underlying Session are still valid. See our
    * [How to use Stytch Session JWTs](https://stytch.com/docs/guides/sessions/using-jwts) guide for more
    * information.

     * @param \Stytch\Consumer\Models\Sessions\AuthenticateRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authenticateAsync(
        \Stytch\Consumer\Models\Sessions\AuthenticateRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/sessions/authenticate', $data);
        return $promise->then(function ($response) {
            return \Stytch\Consumer\Models\Sessions\AuthenticateResponse::fromArray($response);
        });
    }

    /**
        * Revoke a Session, immediately invalidating all of its session tokens. You can revoke a session in three
        * ways: using its ID, or using one of its session tokens, or one of its JWTs. This endpoint requires
        * exactly one of those to be included in the request. It will return an error if multiple are present.

         * @param \Stytch\Consumer\Models\Sessions\RevokeRequest|array $request
         * @return \Stytch\Consumer\Models\Sessions\RevokeResponse
         */
    public function revoke(
        \Stytch\Consumer\Models\Sessions\RevokeRequest|array $request,
    ): \Stytch\Consumer\Models\Sessions\RevokeResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/sessions/revoke', $data);
        return \Stytch\Consumer\Models\Sessions\RevokeResponse::fromArray($response);
    }

    /**
    * Revoke a Session, immediately invalidating all of its session tokens. You can revoke a session in three
    * ways: using its ID, or using one of its session tokens, or one of its JWTs. This endpoint requires
    * exactly one of those to be included in the request. It will return an error if multiple are present.

     * @param \Stytch\Consumer\Models\Sessions\RevokeRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeAsync(
        \Stytch\Consumer\Models\Sessions\RevokeRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/sessions/revoke', $data);
        return $promise->then(function ($response) {
            return \Stytch\Consumer\Models\Sessions\RevokeResponse::fromArray($response);
        });
    }

    /**
        * Migrate a session from an external OIDC compliant endpoint. Stytch will call the external UserInfo
        * endpoint defined in your Stytch Project settings in the [Dashboard](https://stytch.com/dashboard), and
        * then perform a lookup using the `session_token`. If the response contains a valid email address, Stytch
        * will attempt to match that email address with an existing User and create a Stytch Session. You will
        * need to create the user before using this endpoint.

         * @param \Stytch\Consumer\Models\Sessions\MigrateRequest|array $request
         * @return \Stytch\Consumer\Models\Sessions\MigrateResponse
         */
    public function migrate(
        \Stytch\Consumer\Models\Sessions\MigrateRequest|array $request,
    ): \Stytch\Consumer\Models\Sessions\MigrateResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/sessions/migrate', $data);
        return \Stytch\Consumer\Models\Sessions\MigrateResponse::fromArray($response);
    }

    /**
    * Migrate a session from an external OIDC compliant endpoint. Stytch will call the external UserInfo
    * endpoint defined in your Stytch Project settings in the [Dashboard](https://stytch.com/dashboard), and
    * then perform a lookup using the `session_token`. If the response contains a valid email address, Stytch
    * will attempt to match that email address with an existing User and create a Stytch Session. You will
    * need to create the user before using this endpoint.

     * @param \Stytch\Consumer\Models\Sessions\MigrateRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function migrateAsync(
        \Stytch\Consumer\Models\Sessions\MigrateRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/sessions/migrate', $data);
        return $promise->then(function ($response) {
            return \Stytch\Consumer\Models\Sessions\MigrateResponse::fromArray($response);
        });
    }

    /**
        * Use this endpoint to exchange a Connected Apps Access Token back into a Stytch Session for the
        * underlying User.
        * This session can be used with the Stytch SDKs and APIs.
        *
        * The Session returned will be the same Session that was active in your application (the authorizing
        * party) during the initial authorization flow.
        *
        * The Access Token must contain the `full_access` scope (only available to First Party clients) and must
        * not be more than 5 minutes old. Access Tokens may only be exchanged a single time.

         * @param \Stytch\Consumer\Models\Sessions\ExchangeAccessTokenRequest|array $request
         * @return \Stytch\Consumer\Models\Sessions\ExchangeAccessTokenResponse
         */
    public function exchangeAccessToken(
        \Stytch\Consumer\Models\Sessions\ExchangeAccessTokenRequest|array $request,
    ): \Stytch\Consumer\Models\Sessions\ExchangeAccessTokenResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/sessions/exchange_access_token', $data);
        return \Stytch\Consumer\Models\Sessions\ExchangeAccessTokenResponse::fromArray($response);
    }

    /**
    * Use this endpoint to exchange a Connected Apps Access Token back into a Stytch Session for the
    * underlying User.
    * This session can be used with the Stytch SDKs and APIs.
    *
    * The Session returned will be the same Session that was active in your application (the authorizing
    * party) during the initial authorization flow.
    *
    * The Access Token must contain the `full_access` scope (only available to First Party clients) and must
    * not be more than 5 minutes old. Access Tokens may only be exchanged a single time.

     * @param \Stytch\Consumer\Models\Sessions\ExchangeAccessTokenRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exchangeAccessTokenAsync(
        \Stytch\Consumer\Models\Sessions\ExchangeAccessTokenRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/sessions/exchange_access_token', $data);
        return $promise->then(function ($response) {
            return \Stytch\Consumer\Models\Sessions\ExchangeAccessTokenResponse::fromArray($response);
        });
    }

    /**
        * Get the JSON Web Key Set (JWKS) for a project.
        *
        * Within the JWKS, the JSON Web Keys are rotated every ~6 months. Upon rotation, new JWTs will be signed
        * using the new key, and both keys will be returned by this endpoint for a period of 1 month.
        *
        * JWTs have a set lifetime of 5 minutes, so there will be a 5 minute period where some JWTs will be signed
        * by the old keys, and some JWTs will be signed by the new keys. The correct key to use for validation is
        * determined by matching the `kid` value of the JWT and key.
        *
        * If you're using one of our [backend SDKs](https://stytch.com/docs/b2b/sdks), the JSON Web Key (JWK)
        * rotation will be handled for you.
        *
        * If you're using your own JWT validation library, many have built-in support for JWK rotation, and you'll
        * just need to supply this API endpoint. If not, your application should decide which JWK to use for
        * validation by inspecting the `kid` value.
        *
        * See our [How to use Stytch Session JWTs](https://stytch.com/docs/guides/sessions/using-jwts) guide for
        * more information.

         * @param \Stytch\Consumer\Models\Sessions\GetJWKSRequest|array $request
         * @return \Stytch\Consumer\Models\Sessions\GetJWKSResponse
         */
    public function getJWKS(
        \Stytch\Consumer\Models\Sessions\GetJWKSRequest|array $request,
    ): \Stytch\Consumer\Models\Sessions\GetJWKSResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->get('/v1/sessions/jwks/{project_id}', $data);
        return \Stytch\Consumer\Models\Sessions\GetJWKSResponse::fromArray($response);
    }

    /**
    * Get the JSON Web Key Set (JWKS) for a project.
    *
    * Within the JWKS, the JSON Web Keys are rotated every ~6 months. Upon rotation, new JWTs will be signed
    * using the new key, and both keys will be returned by this endpoint for a period of 1 month.
    *
    * JWTs have a set lifetime of 5 minutes, so there will be a 5 minute period where some JWTs will be signed
    * by the old keys, and some JWTs will be signed by the new keys. The correct key to use for validation is
    * determined by matching the `kid` value of the JWT and key.
    *
    * If you're using one of our [backend SDKs](https://stytch.com/docs/b2b/sdks), the JSON Web Key (JWK)
    * rotation will be handled for you.
    *
    * If you're using your own JWT validation library, many have built-in support for JWK rotation, and you'll
    * just need to supply this API endpoint. If not, your application should decide which JWK to use for
    * validation by inspecting the `kid` value.
    *
    * See our [How to use Stytch Session JWTs](https://stytch.com/docs/guides/sessions/using-jwts) guide for
    * more information.

     * @param \Stytch\Consumer\Models\Sessions\GetJWKSRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJWKSAsync(
        \Stytch\Consumer\Models\Sessions\GetJWKSRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->getAsync('/v1/sessions/jwks/{project_id}', $data);
        return $promise->then(function ($response) {
            return \Stytch\Consumer\Models\Sessions\GetJWKSResponse::fromArray($response);
        });
    }

    /**
        * Exchange an auth token issued by a trusted identity provider for a Stytch session. You must first
        * register a Trusted Auth Token profile in the Stytch dashboard
        * [here](https://stytch.com/dashboard/trusted-auth-tokens). If a session token or session JWT is provided,
        * it will add the trusted auth token as an authentication factor to the existing session.

         * @param \Stytch\Consumer\Models\Sessions\AttestRequest|array $request
         * @return \Stytch\Consumer\Models\Sessions\AttestResponse
         */
    public function attest(
        \Stytch\Consumer\Models\Sessions\AttestRequest|array $request,
    ): \Stytch\Consumer\Models\Sessions\AttestResponse {
        $data = is_array($request) ? $request : $request->toArray();
        $response = $this->client->post('/v1/sessions/attest', $data);
        return \Stytch\Consumer\Models\Sessions\AttestResponse::fromArray($response);
    }

    /**
    * Exchange an auth token issued by a trusted identity provider for a Stytch session. You must first
    * register a Trusted Auth Token profile in the Stytch dashboard
    * [here](https://stytch.com/dashboard/trusted-auth-tokens). If a session token or session JWT is provided,
    * it will add the trusted auth token as an authentication factor to the existing session.

     * @param \Stytch\Consumer\Models\Sessions\AttestRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attestAsync(
        \Stytch\Consumer\Models\Sessions\AttestRequest|array $request,
    ): \GuzzleHttp\Promise\PromiseInterface {
        $data = is_array($request) ? $request : $request->toArray();
        $promise = $this->client->postAsync('/v1/sessions/attest', $data);
        return $promise->then(function ($response) {
            return \Stytch\Consumer\Models\Sessions\AttestResponse::fromArray($response);
        });
    }

    // MANUAL(authenticateJwt)(SERVICE_METHOD)
    // ADDIMPORT: use Stytch\Shared\JwksCache;
    // ADDIMPORT: use Stytch\Shared\JwtHelpers;

    /**
     * Parse a JWT and verify the signature, preferring local verification over remote.
     *
     * Tries local JWT validation first for performance. If local validation fails for any
     * reason (invalid signature, expired, etc.), falls back to network authentication.
     *
     * If max_token_age_seconds is set, remote verification will be forced if the JWT was issued
     * (based on the "iat" claim) more than that many seconds ago.
     *
     * To force remote validation for all tokens, set max_token_age_seconds to zero or use the
     * authenticate method instead.
     *
     * @param \Stytch\Consumer\Models\Sessions\AuthenticateJwtRequest|array $request
     * @return \Stytch\Consumer\Models\Sessions\AuthenticateResponse
     */
    public function authenticateJwt(
        \Stytch\Consumer\Models\Sessions\AuthenticateJwtRequest|array $request
    ): \Stytch\Consumer\Models\Sessions\AuthenticateResponse {
        $data = is_array($request) ? $request : $request->toArray();

        try {
            $session = $this->authenticateJwtLocal($request);

            // Return same response format as authenticate()
            // Build a response that matches AuthenticateResponse structure
            $responseData = [
                'status_code' => 200,
                'request_id' => '',
                'session' => $session,
                'session_token' => '',
                'session_jwt' => $data['session_jwt'],
            ];

            return \Stytch\Consumer\Models\Sessions\AuthenticateResponse::fromArray($responseData);
        } catch (\Exception $e) {
            // JWT could not be verified locally. Fall back to Stytch API.
            return $this->authenticate([
                'session_jwt' => $data['session_jwt'],
                'authorization_check' => $data['authorization_check'] ?? null,
            ]);
        }
    }

    /**
     * Parse a JWT and verify the signature locally (without calling /authenticate in the API).
     *
     * If max_token_age_seconds is set, this will return an error if the JWT was issued (based on the "iat"
     * claim) more than max_token_age_seconds seconds ago.
     *
     * If max_token_age_seconds is explicitly set to zero, all tokens will be considered too old,
     * even if they are otherwise valid.
     *
     * The value for current_date is used to compare timestamp claims ("exp", "nbf", "iat"). It
     * defaults to the current date (new DateTime()).
     *
     * The value for clock_tolerance_seconds is the maximum allowable difference when comparing
     * timestamps. It defaults to zero.
     *
     * @param \Stytch\Consumer\Models\Sessions\AuthenticateJwtLocalRequest|array $request
     * @return \Stytch\Consumer\Models\Sessions\Session
     * @throws \Stytch\Core\StytchException
     */
    public function authenticateJwtLocal(
        \Stytch\Consumer\Models\Sessions\AuthenticateJwtLocalRequest|array $request
    ): \Stytch\Consumer\Models\Sessions\Session {
        $data = is_array($request) ? $request : $request->toArray();

        // Fetch JWKS (cached)
        $jwks = $this->jwksCache->fetch($this->projectId);

        // Validate JWT locally
        $sessionData = JwtHelpers::authenticateSessionJwtLocal(
            $jwks,
            $data['session_jwt'],
            $this->projectId,
            [
                'clock_tolerance_seconds' => $data['clock_tolerance_seconds'] ?? null,
                'max_token_age_seconds' => $data['max_token_age_seconds'] ?? null,
                'current_date' => $data['current_date'] ?? null,
            ]
        );

        // TODO: Add RBAC authorization check if supported for Consumer
        // if (isset($data['authorization_check'])) {
        //     $policy = $this->policyCache->getPolicy();
        //     // Perform authorization check
        // }

        // Map to Session object
        return \Stytch\Consumer\Models\Sessions\Session::fromArray([
            'session_id' => $sessionData['session_id'],
            'user_id' => $sessionData['sub'],
            'started_at' => $sessionData['started_at'],
            'last_accessed_at' => $sessionData['last_accessed_at'],
            'expires_at' => $sessionData['expires_at'],
            'attributes' => $sessionData['attributes'],
            'authentication_factors' => $sessionData['authentication_factors'],
            'custom_claims' => $sessionData['custom_claims'],
        ]);
    }

    /**
     * Async version of authenticateJwt
     *
     * @param \Stytch\Consumer\Models\Sessions\AuthenticateJwtRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authenticateJwtAsync(
        \Stytch\Consumer\Models\Sessions\AuthenticateJwtRequest|array $request
    ): \GuzzleHttp\Promise\PromiseInterface {
        return \GuzzleHttp\Promise\Create::promiseFor($this->authenticateJwt($request));
    }

    /**
     * Async version of authenticateJwtLocal
     *
     * @param \Stytch\Consumer\Models\Sessions\AuthenticateJwtLocalRequest|array $request
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authenticateJwtLocalAsync(
        \Stytch\Consumer\Models\Sessions\AuthenticateJwtLocalRequest|array $request
    ): \GuzzleHttp\Promise\PromiseInterface {
        return \GuzzleHttp\Promise\Create::promiseFor($this->authenticateJwtLocal($request));
    }
    // ENDMANUAL(authenticateJwt)


}
